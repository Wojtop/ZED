---
title: "Projekt R"
author: "Wojciech Toporowski, 145381"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
---

# Zastosowane biblioteki i powtarzalność
```{r knitr_setup, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message =  FALSE)
knitr::opts_chunk$set(comment =  "")
knitr::opts_chunk$set(tidy =  TRUE)
```
```{r libraries, echo=TRUE}
library(DT)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(plotly)
library(caret)
library(ggcorrplot)
# library(gganimate)

my_seed <- 145381  # numer indeksu jako seed dla operacji losowych
```

```{r setup, include=FALSE}
prettyTable <- function(table_df, round_digits=2) {
    DT::datatable(table_df, style="bootstrap", filter = "top", rownames = FALSE, extensions = "Buttons", options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print'))) %>% formatRound(names(dplyr::select_if(table_df, is.numeric)), round_digits)
}

```
# Dane - tabele, rozmiary zbiorów, podstawowe statystyki

Wtkorzystany zbiór danych składa się z trzech głównych części:

* informacji o zestawach
* informacji o minigigurkach w zestawach
* informacjci o częsciach - ich kategorie, kolory, złożone elementy

Dane są zawarte w poniższych tabelach, a zawarte w nich dane posiadają niżej przedstawione charakterystyki. Niektóre z pól danych (np. adresy url do obrazków przedstawianjących klocek lub figurkę, identyfikatory) zostały przeze mnie pomienięte we wczytywaniu bądź analizie, ze względu na brak merytorycznego wkładu w analizę. Niektóre kolumny otrzymały również zmienione nazwy, aby ułatwić późniejsze łączenie danych.

## Zestawy
### Inventories
Tabela pozwalająca połączyć powyższe 3 części w jedną całość.

```{r inventories, cache = TRUE}
inventories <- read.csv("data/inventories.csv")%>%mutate(set_num = factor(set_num))
str(inventories)
knitr::kable(summary(inventories))

inventories_by_version <- group_by(inventories, version)%>%summarise(count = n())
knitr::kable(inventories_by_version)
p <- (filter(inventories_by_version, version == 1)%>%select(count)/ nlevels(inventories$set_num))[1,]
```
Rozmiar tabeli: ***`r format(nrow(inventories),big.mark=",",scientific=FALSE)`*** wierszy

Ze względu, że tabela jest tak naprawdę tabelą łączącą i skłąda się z samych identyfikatorów, nie wydaje się potrzebna głębsza analiza jej pól. Warto zauważyć, że stanowcza część zestawów (***`r p`%*** została wypuszczona w tylko jednej wersji.

### Sets

Tabela zawiera informację o zestawach: w którym roku były wydane, ile mają części, nazwa zestawu oraz motyw zestawu.

```{r sets,cache = TRUE}
sets <- read.csv("data/sets.csv")%>%mutate(set_num = factor(set_num), name = factor(name), set_num = factor(set_num))%>%rename(set_num_parts = num_parts)%>%select(-img_url)
str(sets)
knitr::kable(summary(sets))
```
Tabela daje nam informację, że obecnie dostępnych jest ***`r format(nrow(sets),big.mark=",",scientific=FALSE)`*** zestawów Lego. Należy zwrócić uwagę, że jest to wartość mniejsza, niż liczba w wpisów w tabeli *inventories*. Wynika to z faktu, że część zetawów wystąpiła w różnych wersjach. Informacja o wersji znaduje się w tabeli *inventories*. Z tego też względu w tamtej tabeli ten sam zestaw może występować kilkukrotnie, z inną wersją.

```{r sets_num_parts}
q <- 90
p <- quantile(sets$set_num_parts, c( q/100))
filtered <- filter(sets, set_num_parts > 0)%>%mutate(small = set_num_parts <= p[1])

w1 <- ggplot(
  filter(filtered, small == TRUE),
       aes(x = set_num_parts)) +
  geom_histogram(binwidth =10)+
  ggtitle(sprintf("Częstotliwości rozmiarów zestawów: część I (percentyl 0-%d%%)",q)) +
  xlab("Rozmiar zestawu") +
  ylab("Częstotliwość występowania") +
  theme_bw()
w2 <- ggplot(filter(filtered, small == FALSE),
       aes(x = set_num_parts)) +
  geom_histogram(binwidth = 1000)+
  ggtitle(sprintf("Częstotliwości rozmiarów zestawów: część II (percentyl %d-100%%)", q)) +
  xlab("Rozmiar zestawu") +
  ylab("Częstotliwość występowania") +
  theme_bw()
ggplotly(w1)
ggplotly(w2)
```

```{r sets_years}

psby<-ggplot(sets,
       aes(x = year)) +
 geom_histogram(binwidth=1)+
  ggtitle("Liczba zestawów wg roku - rozkład parametru \"rok\"") +
  xlab("Rok") +
  ylab("Liczba zestawów") +
  theme_bw()
ggplotly(psby)

```
### Themes

Tabela zawiera informację o motywach zestawów. Motywy są ułożone hierarchicznie - jeden motyw może być zbiorem wielu innych. Motyw posiadający nad sobą motyw macierzysty posiada referencję do niego w polu *parent_id*.

```{r themes,cache = TRUE}
themes <- read.csv("data/themes.csv")%>%mutate(name = factor(name))%>%rename(theme_name = name)
str(themes)
knitr::kable(summary(themes))
```
Z powyższych danych widzimy, że obecnie w Lego mamy dostępne ***`r format(nrow(themes),big.mark=",",scientific=FALSE)`*** motywów, z czego aż ***`r format(nrow(filter(themes, is.na(parent_id))),big.mark=",",scientific=FALSE)`*** to motywy będące korzeniami swoich hierarchii. Możemy też zauważyć, że wśród motywów mamy jedynie ***`r format(nlevels(themes$theme_name),big.mark=",",scientific=FALSE)`*** unikalnych nazw, co ozacza że część motywów dzili nazwy (np. występują 4 motywy o nazwie "Star Wars").

### Inventory sets

Niektóre zestawy mogą składać się kilku innych. Tabela *inventory_sets* zawiera informację, ile zestawów o identyfikatorze *set_num* zawiera zestaw nadzrzędny.

```{r inventory_sets,cache = TRUE}
inventory_sets <- read.csv("data/inventory_sets.csv")%>%mutate(set_num = factor(set_num))%>%rename(set_quantity = quantity)
str(inventory_sets)
knitr::kable(summary(inventory_sets))

complex_sets <-group_by(inventory_sets, inventory_id)%>%summarise(subsets = n_distinct(set_num))
```
W zbiorze tym mamy ***`r format(nrow(inventory_sets),big.mark=",",scientific=FALSE)`*** wpisów, opisujących ***`r format(nrow(complex_sets),big.mark=",",scientific=FALSE)` zestawów złożonych***.
```{r complex_sets_sizes}
psby<-ggplot(complex_sets,
             aes(x = subsets))+
 geom_histogram(binwidth =1)+
  ggtitle("Liczba zestawów wchodząca w skład zestawów złożonych") +
  xlab("Liczba zestawów w zestawie złożonym") +
  ylab("Liczba zestawów złożonych") +
  theme_bw()
ggplotly(psby)
```

## Minifigurki

### Minifigs

Tabela zawiera informację o nazwie oraz liczbie części minifigurki.
```{r minifigs,cache = TRUE}
minifigs <- read.csv("data/minifigs.csv")%>%mutate(name = factor(name), fig_num = factor(fig_num))%>%rename(fig_name = name, fig_num_parts = num_parts)%>%select(-img_url)
str(minifigs)
knitr::kable(summary(minifigs))
```
Tabela zawiera informację o ***`r format(nrow(minifigs),big.mark=",",scientific=FALSE)`*** minifigurkach. Warto zwrócić uwagę, że w zbiorze występuje jedynie ***`r format(nlevels(minifigs$fig_name),big.mark=",",scientific=FALSE)`*** unikalnych nazw figurek, co oznacza, że część różnych figurek posiada tą samą nazwę.

```{r minifigs_attributes}
psby<-ggplot(minifigs,
             aes(x = fig_num_parts))+
 geom_histogram(binwidth =1)+
  ggtitle("Liczba elementów wchodzących w skład figurki (skala logarytmiczna)") +
  xlab("Liczba elementów") +
  ylab("Liczba figurek") +
  scale_y_log10() +
  theme_bw()
ggplotly(psby)
```

### Inventory minifigs

Tabela zawiera informację, ile sztuk danej figurki występuje w danym zestwie.

```{r inventory_minifigs,cache = TRUE}
inventory_minifigs <- read.csv("data/inventory_minifigs.csv")%>%mutate(fig_num = factor(fig_num))%>%rename(fig_quantity = quantity)
str(inventory_minifigs)
knitr::kable(summary(inventory_minifigs))

minifigs_by_inventory <- group_by(inventory_minifigs, inventory_id)%>%summarise(different_minifigs = n_distinct(fig_num), fig_sum = sum(fig_quantity))
```
Zbiór zawiera ***`r format(nrow(inventory_minifigs),big.mark=",",scientific=FALSE)`*** wpisów na temat figurek w ***`r format(nrow(minifigs_by_inventory),big.mark=",",scientific=FALSE)`*** zestawach.

```{r inventory_minifigs_attributes}
psby<-ggplot(inventory_minifigs,
             aes(x = fig_quantity))+
 geom_histogram(binwidth =1)+
  ggtitle("Częstotliwość wystąpień tej samej figurki w ramach zestawu (skala logarytmiczna)") +
  xlab("Ilośc tej samej figurki") +
  ylab("Liczba wystąpień") +
  scale_y_log10() +
  theme_bw()
ggplotly(psby)
```

Zgrupowanie danych w ramach zestawów pozwala otrzymać następujące dane na temat ogólnej liczby figurek w zestawach oraz liczby unikalnych figurek w ramach zestawu.
Należy pamiętać, że na tym etapie analiza nie uwzględnia zestawów nie posiadających figurek.

```{r inventory_minifigs_grouped}
knitr::kable(summary(minifigs_by_inventory))

psby<-ggplot(minifigs_by_inventory,
             aes(x = different_minifigs))+
geom_histogram(binwidth =1)+
  ggtitle("Liczba różnych figurek w ramach zestawu (skala logarytmiczna)") +
  xlab("Ilość różnych figurek") +
  ylab("Liczba zestawów") +
  scale_y_log10() +
  theme_bw()
ggplotly(psby)

psby<-ggplot(minifigs_by_inventory,
             aes(x = fig_sum))+
geom_histogram(binwidth =1)+
  ggtitle("Liczba figurek w ramach zestawu (skala logarytmiczna)") +
  xlab("Ilość figurek") +
  ylab("Liczba zestawów") +
  scale_y_log10() +
  theme_bw()
ggplotly(psby)

```

## Części

### Inventory parts

Tabela zawiera listę części występujących w ramach zestawu. Zawiera informację o identyfikatorze części, jej ilości, kolorze (ta sama część może występować w ramach zestawu w różnych kolorach) oraz czy część jest zapasowa (nadmiarowa w zestawie względem wymaganej liczby).

```{r inventory_parts,cache = TRUE}
inventory_parts <- read.csv("data/inventory_parts.csv")%>%mutate(is_spare = factor(is_spare), part_num = factor(part_num))%>%rename(part_quantity = quantity)%>%select(-img_url)
str(inventory_parts)
knitr::kable(summary(inventory_parts))

all_parts <- sum(inventory_parts$part_quantity)
spare_parts <- sum(filter(inventory_parts, is_spare == 't')$part_quantity)
```
Zbiór posiada ***`r format(nrow(inventory_parts),big.mark=",",scientific=FALSE)`*** wierszy opisujących zastosowanie ***`r format(nlevels(inventory_parts$part_num),big.mark=",",scientific=FALSE)`*** różnych części w zestawach.

Wynika z niego, że ***`r format(round(spare_parts/all_parts, 2), nsmall = 2)`%*** części otrzymywanych w ramach zestawów, to części zapasowe.

```{r inventory_parts_attributes}
t<- data.frame(y = c(all_parts- spare_parts, spare_parts), zapasowe = c("nie", "tak"))
ggplotly(
  ggplot(data=t, aes(x=NA, y=y, fill=zapasowe)) +
  geom_bar(stat="identity") +
    ggtitle("Stosunek części zapasowych do zwykłych w zestawach") +
  xlab("") +
  ylab("Liczba częsci") +
  coord_flip() +
    scale_y_continuous(labels = scales::comma) +
    theme_bw()
)


q<-95
psby<-ggplot(filter(inventory_parts, part_quantity <= quantile(inventory_parts$part_quantity, q/100)),
             aes(x = part_quantity))+
geom_histogram(binwidth =1)+
  ggtitle(sprintf("Częstotliwość rozkładu parametru \"part_quantity\" (0-%d%% wpisów)", q)) +
  xlab("Ilość sztuk") +
  ylab("Liczba wystąpień") +
  scale_y_continuous(labels = scales::comma) +
  theme_bw()
ggplotly(psby)
```
### Colors
Tabela zawiera dane o kolorach klocków. Zawiera nazwę koloru, jego wartość RGB zapisaną szesnastkowo i informację, czy jest przezroczysty.

```{r colors,cache = TRUE}
colors <- read.csv("data/colors.csv")%>%mutate(is_trans = factor(is_trans), name = factor(name))%>%rename(color_name = name)
str(colors)
knitr::kable(summary(colors))
```
Dane w tabeli opisują ***`r format(nrow(colors),big.mark=",",scientific=FALSE)`*** kolorów.
```{r colors_attributes}
by_trans <- group_by(colors, is_trans)%>%summarise(count = n())
ggplotly(
  ggplot(by_trans, aes(x=NA, y=count, fill=is_trans)) +
  geom_bar(stat="identity") +
    ggtitle("Stosunek kolorów przezroczystych do nieprzezroczystych") +
  xlab("") +
  ylab("Liczba kolorów") +
  coord_flip() +
    scale_y_continuous(labels = scales::comma) +
    theme_bw()
)
```


### Parts i part categories
Tabela parts zawiera katalog części Lego. Niektóre części mogą składać się z kilku elementów. Zawiera nazwę części oraz identyfikator kategorii, do której należy część.Z kolei tabela part_categories zawiera listę kategorii, do których są klasyfikowane klocki. Aby skrócić analizę, pozwoliłem sobie od razu połączyć te dwie tabele i pokazać ich połączony rozkład atrybutów.

#### Parts

```{r parts,cache = TRUE}
parts <- read.csv("data/parts.csv")%>%mutate(name = factor(name), part_num=factor(part_num), part_material = factor(part_material))%>%rename(part_name = name)
str(parts)
knitr::kable(summary(parts))
```

Tabela parts opisuje ***`r format(nrow(parts),big.mark=",",scientific=FALSE)`*** części Lego. Z prównania tej tabeli oraz danych z tabeli inventory parts, możemy zauważyć, że liczba wszystkich dostępnych części oraz części używanych w zestawach jest różna (nie wszystkie części mają użycie w zestawach).

```{r parts_materials}
psby<-ggplot(parts,
             aes(x = part_material))+
geom_bar()+
  ggtitle("Liczba dostępnych części w zależności od materiału") +
  xlab("Materiał") +
  ylab("Liczba części") +
  scale_y_log10() +
  theme_bw() +
  scale_y_continuous(labels = scales::comma) +
  coord_flip()
ggplotly(psby)
```

#### Parts categories
```{r parts_categories,cache = TRUE}
parts_cat <- read.csv("data/part_categories.csv")%>%mutate(name = factor(name))%>%rename(category_name = name)
str(parts_cat)
knitr::kable(summary(parts_cat))
```
Tabela part categories opisuje ***`r format(nrow(parts_cat),big.mark=",",scientific=FALSE)`*** kategorii części Lego.

```{r parts_categories_attr, fig.height=10}
parts_categories <- full_join(parts, parts_cat, join_by(part_cat_id == id))
knitr::kable(summary(parts_categories))

psby<-ggplot(group_by(parts_categories,category_name)%>%summarise(count= n()),
             aes(x = reorder(category_name, count, decreasing=TRUE), y = count))+
geom_bar(stat='identity')+
  ggtitle("Liczba części w kategoriach") +
  xlab("Kategoria") +
  ylab("Liczba części") + 
  theme_bw() +
  scale_y_continuous(labels = scales::comma) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
ggplotly(psby)
```
### Elements

Jak wspomniano wyżej, niektóre części mogą składać się z kilku klocków. W tabeli elements zebrano informacje, do jakich części przynależą poszczególne klocki.

```{r elements,cache = TRUE}
elements <- read.csv("data/elements.csv")%>%mutate(part_num = factor(part_num))
str(elements)
knitr::kable(summary(elements))

elements_grouped <- group_by(elements, part_num) %>%summarise(elements_count = n(), distinct_elements = n_distinct(part_num))
summary(elements_grouped$elements_count)
```

Tabela zawiera ***`r format(nrow(elements),big.mark=",",scientific=FALSE)`*** wpisów zawierających opis ***`r format(nrow(elements_grouped),big.mark=",",scientific=FALSE)`*** złożonych części.

Charakterystyka liczby klocków w elemencie złożonym:
```{r elements_count_stat}
summary(elements_grouped$elements_count)
```
Charakterystyka liczby unikalnych klocków w elemencie złożonym:
```{r elements_count_stat_2}
summary(elements_grouped$distinct_elements)
```


### Part relationships

Tabela zawiera informacje o relacjach zachodzących między częściami.

```{r parts_relationships,cache = TRUE}
parts_relationships <- read.csv("data/part_relationships.csv")%>%mutate(rel_type = factor(rel_type), parent_part_num = factor(parent_part_num), child_part_num = factor(child_part_num))
str(parts_relationships)
knitr::kable(summary(parts_relationships))
```
Dane zawierają ***`r format(nrow(parts_relationships),big.mark=",",scientific=FALSE)`*** wpisów.

```{r parts_relations_attr}
psby<-ggplot(group_by(parts_relationships,rel_type)%>%summarise(count= n()),
             aes(x = reorder(rel_type, count, decreasing=TRUE), y = count))+
geom_bar(stat='identity')+
  ggtitle("Rozkład relacji pomiędzy częściami") +
  xlab("Relacja") +
  ylab("Liczba relacji") + 
  theme_bw() +
  scale_y_continuous(labels = scales::comma) +
  coord_flip() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
ggplotly(psby)
```
# Analizy
```{r knitr_setup3, echo=FALSE}
# knitr::opts_chunk$set(echo = TRUE)
# knitr::opts_chunk$set(cache = TRUE)
# knitr::opts_chunk$set(warning = FALSE)
# knitr::opts_chunk$set(message =  FALSE)
# knitr::opts_chunk$set(comment =  "")
# knitr::opts_chunk$set(tidy =  TRUE)
```

W ramach projektu chciałbym skupić się na analizie następujących elementów na przestrzeni lat:

- jak zmieniała się liczba motywów zestawów Lego i ile zestawów należy do każdego z głównych motywów
- jak zmieniała się liczba figurek w zestawach oraz złożoność figurek
- jak zmieniała się liczba kolorów stosowanych w zestawach

Ponieważ rok dostępny jest tylko w tabeli *sets*, wyekstrachuję rok i numer zestawu do osobnej tabeli, którą później będę mógł łączyć z innymi. W ten sposób uzyskam dostęp do roku w analizach innych tabel.

```{r year_table,cache = TRUE}
sets_years <- select(sets, set_num, year)
```

## Liczba motywów i zestawów w motywach

W celu tej analizy połączymy tabele *sets* oraz *themes*. 

```{r sets_themes_join,cache = TRUE}
st <- full_join(sets, themes, join_by(theme_id == id))
knitr::kable(summary(st))
filter(st, is.na(set_num))
```
Dokonując pełnego połączenia widzimy motywy, nie posiadające zestawów. Są to prawdopodobnie motywy nadrzędne, do których bezpośrednio nie został przypisany żaden zestaw. Taka informacja niczego nie wnosi do wybranej analizy, stąd wykonam połączenie, wybierające jedynie motywy powiązane z zestawami.

```{r sets_themes_join2,cache = TRUE}
st <- left_join(sets, themes, join_by(theme_id == id))
knitr::kable(summary(st))
filter(st, is.na(set_num))
```
Dla każdego zestawu znajdźmy najwyższy motyw w hierarchii.

```{r primary_theme,cache = TRUE}
primary_theme <- function(theme_id){
  parent <- filter(themes, id == theme_id)
  if(is.na(parent$parent_id)[1])
   { theme_id}
  else
  {
    primary_theme(parent$parent_id)
  }
}
st <- st%>%rowwise()%>%mutate(primary_theme_id = primary_theme(theme_id))
st<-st%>%mutate(primary_theme_name = filter(themes, id == primary_theme_id )$theme_name)%>%mutate(primary_theme_name = factor(primary_theme_name))
knitr::kable(summary(st))
knitr::kable(head(st))
```
Teraz możemy przejść do analizy. Dla każdego roku sprawdzimy liczbę wszystkich motywów, liczbę głównych motywów oraz liczbę zestawów dla każdego motywu i motywu głównego. Do obliczeń korzytam z grupowania po ***nazwie motywu***, a nie jego identyfikatorze. Uznaję, że motyw "Star Wars" to motyw "Star Wars" i nie interesują mnie wenętrzne różnice między nimi.

```{r st_analysis}
themes_count_by_year <- st%>%group_by(year)%>%summarise(themes_count = n_distinct(theme_name), primary_themes_count = n_distinct(primary_theme_name))
themes_count_by_year <- themes_count_by_year%>%gather(type, count, themes_count:primary_themes_count)

ggplotly(ggplot(themes_count_by_year,
             aes(x = year, y = count, fill = type))+
geom_bar(stat='identity', position = 'dodge')+
  ggtitle("Porównanie liczby motywów oraz motywów głównych w kolejnych latach") +
  xlab("Rok") +
  ylab("Liczba motywów") + 
  theme_bw() +
  scale_y_continuous(labels = scales::comma) )
```

Jak widać, liczba motywów używanych przez Lego rośnie. Oprócz tego widzimy, że w każdym roku pojawia się więcej motywów niż motywów głównych, co ozacza że Lego każdego roku wypuszcza zestawy w różnych grupach, należących do tego samego motywu nadrzędnego.

```{r st_analysis_2, fig.width=15, fig.height=10}
sets_by_theme <- st%>%group_by(year, theme_name)%>%summarise(sets_count = n_distinct(set_num))
mean_by_year <- sets_by_theme%>%group_by(year)%>%summarise(mean=(mean(sets_count)), median = median(sets_count))

ggplotly(
  ggplot(sets_by_theme, aes(x=year, y = sets_count))
  + geom_boxplot(outlier.shape = NA)
  + geom_line(data = mean_by_year, aes(x = year, y = median))
  + ggtitle("Charakterystyki ilości zestawów w motywach w latach")
  + xlab("Rok")
  + ylab("Liczba zestawów")
  + theme_bw()
)

sets_by_primary_theme <- st%>%group_by(year, primary_theme_name)%>%summarise(sets_count = n_distinct(set_num))
primary_mean_by_year <- sets_by_theme%>%group_by(year)%>%summarise(mean=(mean(sets_count)), median = median(sets_count))

ggplotly(
  ggplot(sets_by_primary_theme, aes(x=year, y = sets_count))
  + geom_boxplot(outlier.shape = NA)
  + geom_line(data = primary_mean_by_year, aes(x = year, y = median))
  + ggtitle("Charakterystyki ilości zestawów w motywach głównych w latach")
  + xlab("Rok")
  + ylab("Liczba zestawów")
  + theme_bw()
  
)

```
```{r, fig.width=15, fig.height=15}
ggplotly(
  ggplot(st, aes(x = year, y = primary_theme_name)) +
    geom_jitter() +
    theme_bw() +
    ggtitle("Zestawy w motywach głównych w latach") +
  xlab("Rok") + 
   ylab("Motyw")
)
```
Patrząc na powyższe wykresy można stwierdzić, że wraz z biegiem lat liczba zestawów w ramach motywów nie zmienia się znacząco. Kwantyla oraz mediana dla motywów pozostają w miarę stabilne i zbliżone, co ozncza że każdy motyw co roku dostaje mniej więcej podobną liczbę zestawów co inne. Uwagę jednak zwraca rosnąca w latach dwutysięcznych liczba outlierów. Ozancza to, ze kilka motywów otrzymuje zdecydowanie więcej zestawów, niż reszta.


## Liczba figurek w zestawach oraz złożoność figurek

Aby przeprowadzić tę analizę musimy połaczyć 3 tabele: *minifigs, invenotry_minifigs, inventories* oraz dodać do nich inforamcję o roku, z utworzonej wcześniej tabeli pomocniczej.

```{r minifigs_analysis_join}

mfdf <- full_join(minifigs, inventory_minifigs, by='fig_num')
mfdf <- full_join(inventories, mfdf, join_by(id == inventory_id))
mfdf <- full_join(sets_years, mfdf, by='set_num')
knitr::kable(summary(mfdf))
```
W każdej z kolumn utworzonego zbioru mamy wartości puste. Przyjrzyjmy się, co one oznaczają:

```{r}
t <- mfdf%>%filter(is.na(set_num))
knitr::kable(summary(t))
knitr::kable(head(t))
```
Puste pola w kolumnach *set_num, year, id, version, fig_quantity* wynikają z istnienia figurek, które nigdy nie trafiły do żadnego zestawu. Na podstawie powyższego zbioru możemy zobaczyć, że jest ich ***`r format(nrow(t),big.mark=",",scientific=FALSE)`***. Usuńmy te wiersze ze zbioru.

```{r}
t <- mfdf%>%filter(! is.na(set_num))
knitr::kable(summary(t))
knitr::kable(head(t))
```
Puste wartości w kolumnach *fig_name, fig_num_parts, fig_quantity* wynikają z zestawów, które nie mają figurek. Zestawów takich jest ***`r format(nrow(filter(t, is.na(fig_num) & is.na(fig_num_parts) & is.na(fig_name) & is.na(fig_quantity) )),big.mark=",",scientific=FALSE)`***. Usuńmy te wpisy ze zbioru

```{r}
mfdf <- filter(mfdf, !is.na(fig_num) & !is.na(fig_num_parts) & !is.na(fig_name) & !is.na(fig_quantity))
knitr::kable(summary(mfdf))
knitr::kable(head(mfdf))
```

Ostatecznie otrzymujemy oczysczony zbiór bez wartości pustych, który zawiera ***`r format(nrow(mfdf),big.mark=",",scientific=FALSE)`*** wpisów, opisujących ile i jakich figurek należy do jakiego zestawu oraz ile te figurki mają części. 

Sprawdźmy, jak wygląda rozkład liczby fiurek w zestawach.

```{r minifigs_analysis}

by_set <- mfdf %>% group_by(set_num) %>% summarise(fig_sum = sum(fig_quantity),different_figs = n_distinct(fig_num))
by_year <-inner_join(by_set, sets_years, by = 'set_num') %>% select(-set_num)

p99 <- quantile(by_year$fig_sum, 0.99)

ggplotly(
ggplot(by_year, aes(x = year, y = fig_sum)) +
  geom_boxplot(outlier.shape = NA)+ 
  ggtitle("Suma figurek per zestaw w kolejnych latach (percentyl 99)")+ 
  xlab("Rok") +
  ylab("Suma figurek")+ 
  ylim(0, p99)+
theme_bw()  
)

p99 <- quantile(by_year$different_figs, 0.99)
ggplotly(
ggplot(by_year, aes(x = year, y = different_figs)) +
  geom_boxplot(outlier.shape = NA)+ 
  ggtitle("Liczba różncych figurek per zestaw w kolejnych latach (percentyl 99)")+ 
  xlab("Rok") +
  ylab("Suma figurek")+ 
  ylim(0, p99)+
theme_bw()  
)
```
Na powyższych wykresach widzimy, że zawartość figurek w ramach zestawów jak i ich różnorodność jest raczej stała i są to najczęściej 2 figurki. Najwięcej figurek można znaleźć w zestawach z lat 2004-2010, kiedy do zestawów trafiały najczęściej 3-4 figurki.

Teraz przeanalizujmy złożoność figurek na przestrzeni lat.

```{r}
complexity <- mfdf%>%select(year, fig_num, fig_num_parts)%>%group_by(year, fig_num)

p95 <- quantile(complexity$fig_num_parts, 0.95)

ggplotly(
ggplot(complexity, aes(x = year, y = fig_num_parts)) +
  geom_boxplot(outlier.shape = NA)+ 
  ggtitle("Złożoność figurek w latach (percentyl 95)")+ 
  xlab("Rok") +
  ylab("Liczba części figurki")+ 
  ylim(0, p95)+
theme_bw()  
)
ggplotly(
ggplot(complexity, aes(x = year, y = fig_num_parts)) +
  geom_boxplot(outlier.shape = NA)+ 
  ggtitle("Złożoność figurek w latach (całość)")+ 
  xlab("Rok") +
  ylab("Liczba części figurki")+ 
theme_bw()  
)
```
Na powyższych dancyh widać, że złożoność figurek jest raczej stała i na poziomie 3-5 części. Jednak na drugim wykresie widzimy rosnącą liczbę outlierów, czyli figurek o większej złożoności niż standardowa.

Poniższe zestawianie przedstawia, jakie motywy posidały najwięcej złożonych figurek i w jakim okresie.

```{r, fig.height=10, fig.width=10}
high_complex <- filter(mfdf, fig_num_parts >= p95)%>%inner_join(st, by='set_num')%>%group_by(primary_theme_name, year.x)%>%summarise(figures = n_distinct(fig_name))%>%rename(year = year.x)
knitr::kable(summary(high_complex))
prettyTable(high_complex)

ggplotly(
ggplot( filter(mfdf, fig_num_parts >= p95)%>%inner_join(st, by='set_num')%>%rename(year = year.x), aes(x=year, y=primary_theme_name))+
  geom_jitter() +
  scale_y_discrete() +
  theme_bw() +
  ggtitle("Figurki o złożności większej niż 95% pozostałych figurek w czasie i motywach")+ 
  xlab("Rok") +
  ylab("Motyw")
)

```

## Liczba kolorów stosowanych w zestawach

Ostatnią anlizą, której chciałbym się podjąć, jest zbadanie liczby kolorów klocków na przstrzeni lat oraz tego ile kolorów przeciętnie występuje w zestawie.


W tym celu na początek połączymy tabele *inventories, inventory_parts* zwierające informacje o częściach w zestawach, również ich kolory. W analizie zawartości tabeli *colors* możemy zauważyć, że nie ma duplikatów wśród nazw kolorów (mamy tyle nazw co identyfikatorów), stąd nie będę dołączać tabeli *colors*, a analizę oprę na identyfikatorach kolorów.

```{r colors_analysis}
ca <- inner_join(inventories, inventory_parts, join_by(id == inventory_id))%>%inner_join( sets_years, by='set_num')

distinct_colors_by_year <- ca%>%group_by(year) %>% summarise(distinct_colors = n_distinct(color_id))

ggplotly(
  ggplot(distinct_colors_by_year, aes(x=year, y = distinct_colors))+
    geom_bar(stat = 'identity') +
    theme_bw() +
    ggtitle("Liczba różnych kolorów stosowana we wszystkich zestawach z danego roku")+ 
  xlab("Rok") +
  ylab("Liczba kolorów")
)

```
Widzimy, że najwięcej kolorów było stosowanych w zestawach z lat 2000-2006. Po roku 2006 widzimy tendencję wzrostową, jednakże nie tak gwałtowną jak wcześniej. Generalna tendencja jest wzrostowa, czyli klocki mają coraz więcej kolorów.

Teraz sprawdźmy, jak zmienia się liczba użytych kolorów ramach zestawu.

```{r colors_analysis_2}

colors_by_set <- ca%>%group_by(year, set_num) %>% summarise(set_colors = n_distinct(color_id))

ggplotly(
  ggplot(colors_by_set, aes(x=year, y = set_colors))
  + geom_boxplot(outlier.shape = NA)
  + ggtitle("Liczby kolorów per zestaw w latach")
  + xlab("Rok")
  + ylab("Liczba kolorów")
  + theme_bw()
)

```
Z powyższego wykresy możemy wnioskować, że obecnie w ramach jednego zestawu najczęściej stosuje się koło kilkunastu kolorów. Do roku 1997 w większości przypadków było to mniej niż 10 kolorów. Od tamtego czasu zaczęło się pojawiać coraz więcej wielokolorowych zestawów (rosnąca liczba outlierów), po czym w roku 2003 zaczął się systematyczny wzrost. Wzrosła zarówno mediana kolorów, z około 5-6 w latach 90 i wcześniej, do 9-12 w drugim dziesięcileciu lat dwutysięcznych. Również "wąsy" rosnące w latach dwutysięcznych wskazują na rosnącą liczbę zestawów o kolorsytyce znacząco większej, niż większość zestawów. Podsumowując wszystko razem: najczęstsza liczba kolorów w zestawach wzrosła od około 5-6 do 9-12 oraz wzrosła liczba zestawów, które używają większej liczby kolorów niż większość.

# Dalsze predykcje

W ramach projektu chciałbym podjąć się utworzenia modelu, który będzie przewidywać następującą informację: jakiego kolorou będzie dana część, na podstawie informacji o jej kategorii, liczbie tej części w zestawie, motywu zestawu, liczbie kategorii

JAKIEGO KOLORU BĘDZIE KLOCEK ???? 

```{r prediction_data_set, cache=TRUE}
# data_set<- st%>%select(-theme_id, - parent_id, -primary_theme_id)%>%inner_join(ca, by='set_num')%>%rename(year = year.x)%>%select(-year.y)
# data_set<- data_set%>%inner_join(colors, join_by(color_id == id))
# data_set<- data_set%>%select(-c(name, id, version, color_id, rgb, is_trans))
# data_set <- data_set%>%inner_join(parts_categories, by='part_num')%>%select(-part_cat_id, -part_name)
# 
# cat_c <-data_set%>%group_by(set_num)%>%summarise(set_categories_count = n_distinct(category_name))
# data_set <- data_set%>%inner_join(cat_c, by='set_num')%>%select(-set_num)
# 
# knitr::kable(summary(data_set))
# knitr::kable(head(data_set))

```
Rozmiar zbioru danych: ***`r format(nrow(data_set),big.mark=",",scientific=FALSE)`***

ALE POWYŻSZY WYSADZAŁ MI KOMPUTER

```{r}
st
fbs <- mfdf %>% group_by(set_num)%>%summarise(fig_sum = sum(fig_quantity), sum_fig_parts = sum(fig_num_parts))
summary(fbs)

# TODO - korelacja przed usuwaniem kolumn

df <- st%>%full_join(fbs, by='set_num')%>%select( -theme_name, -theme_id, -primary_theme_id, -parent_id, -name)



# df <- df%>%inner_join(colors_by_set, by='set_num')%>%select( -year.y, -primary_theme_name, -year.y)%>%rename(year = year.x, )

ipc <- inner_join(inventories, inventory_parts, join_by(id == inventory_id))%>%inner_join(parts, by='part_num')%>%group_by(set_num)%>%summarise(cat_num = n_distinct(part_cat_id), color_num = n_distinct(color_id))

df<- df%>%inner_join(ipc, by='set_num')

colnames(df)

df <- df%>%mutate(fig_sum = coalesce( fig_sum, 0), sum_fig_parts = coalesce(sum_fig_parts, 0))
df <- df%>%mutate(has_figs = if (fig_sum > 0){TRUE} else {FALSE}, has_figs = as.factor(has_figs), primary_theme_name = make.names(primary_theme_name))%>%select(-fig_sum, - sum_fig_parts, -set_num)

summary(df)
colnames(df)

corr <- round(cor(df%>%select(-primary_theme_name)%>%mutate(has_figs = as.numeric(has_figs))), 1)
head(corr)

ggplotly(
  ggcorrplot(corr, method = 'circle', lab = TRUE) + ggtitle("Korelacja między atrybutami liczbowymi badanego zbioru")
)


```

```{r}
summary(df)
knitr::kable(head(df%>%group_by(primary_theme_name)%>%summarise(count = n())%>%arrange(count)))

inTraining <- 
    createDataPartition(
        # atrybut do stratyfikacji
        y = df$primary_theme_name,
        # procent w zbiorze uczącym
        p = .75,
        # chcemy indeksy a nie listę
        list = FALSE)

training <- df[ inTraining,]
testing  <- df[-inTraining,]

summary(training)

# str(training)
knitr::kable(summary(training))
nrow(training)

set.seed(my_seed)
ctrl <- trainControl(
    # powtórzona ocena krzyżowa
    method = "repeatedcv",
  # method="none"
    # liczba podziałów
    number = 5,
    # # liczba powtórzeń
    repeats = 2
)
fit <- train(has_figs ~ .,
             data = training,
             method = "rf",
             trControl = ctrl,
             # Paramter dla algorytmu uczącego
             ntree = 10)

fit
rfClasses <- predict(fit, newdata = testing)
confusionMatrix(data = rfClasses, testing$has_figs)


```



